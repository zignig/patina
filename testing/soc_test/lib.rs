# ! [doc = "Peripheral access API for SOC microcontrollers (generated using svd2rust v0.31.5 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.31.5/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
# ! [allow (non_camel_case_types)]
# ! [allow (non_snake_case)]
# ! [no_std]
use core :: ops :: Deref ; use core :: marker :: PhantomData ; # [allow (unused_imports)]
use generic :: * ; # [doc = r"Common register and bit access and modify traits"]
pub mod generic { use core :: marker ; # [doc = " Raw register type (`u8`, `u16`, `u32`, ...)"]
pub trait RawReg : Copy + Default + From < bool > + core :: ops :: BitOr < Output = Self > + core :: ops :: BitAnd < Output = Self > + core :: ops :: BitOrAssign + core :: ops :: BitAndAssign + core :: ops :: Not < Output = Self > + core :: ops :: Shl < u8 , Output = Self > { # [doc = " Mask for bits of width `WI`"]
fn mask < const WI : u8 > () -> Self ; # [doc = " Mask for bits of width 1"]
fn one () -> Self ; } macro_rules ! raw_reg { ($ U : ty , $ size : literal , $ mask : ident) => { impl RawReg for $ U { # [inline (always)]
fn mask < const WI : u8 > () -> Self { $ mask ::< WI > () } # [inline (always)]
fn one () -> Self { 1 } } const fn $ mask < const WI : u8 > () -> $ U { <$ U >:: MAX >> ($ size - WI) } impl FieldSpec for $ U { type Ux = $ U ; } } ; } raw_reg ! (u8 , 8 , mask_u8) ; raw_reg ! (u16 , 16 , mask_u16) ; raw_reg ! (u32 , 32 , mask_u32) ; raw_reg ! (u64 , 64 , mask_u64) ; # [doc = " Raw register type"]
pub trait RegisterSpec { # [doc = " Raw register type (`u8`, `u16`, `u32`, ...)."]
type Ux : RawReg ; } # [doc = " Raw field type"]
pub trait FieldSpec : Sized { # [doc = " Raw field type (`u8`, `u16`, `u32`, ...)."]
type Ux : Copy + PartialEq + From < Self > ; } # [doc = " Trait implemented by readable registers to enable the `read` method."]
# [doc = ""]
# [doc = " Registers marked with `Writable` can be also be `modify`'ed."]
pub trait Readable : RegisterSpec { } # [doc = " Trait implemented by writeable registers."]
# [doc = ""]
# [doc = " This enables the  `write`, `write_with_zero` and `reset` methods."]
# [doc = ""]
# [doc = " Registers marked with `Readable` can be also be `modify`'ed."]
pub trait Writable : RegisterSpec { # [doc = " Specifies the register bits that are not changed if you pass `1` and are changed if you pass `0`"]
const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux ; # [doc = " Specifies the register bits that are not changed if you pass `0` and are changed if you pass `1`"]
const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux ; } # [doc = " Reset value of the register."]
# [doc = ""]
# [doc = " This value is the initial value for the `write` method. It can also be directly written to the"]
# [doc = " register by using the `reset` method."]
pub trait Resettable : RegisterSpec { # [doc = " Reset value of the register."]
const RESET_VALUE : Self :: Ux ; # [doc = " Reset value of the register."]
# [inline (always)]
fn reset_value () -> Self :: Ux { Self :: RESET_VALUE } } # [doc = " This structure provides volatile access to registers."]
# [repr (transparent)]
pub struct Reg < REG : RegisterSpec > { register : vcell :: VolatileCell < REG :: Ux > , _marker : marker :: PhantomData < REG > , } unsafe impl < REG : RegisterSpec > Send for Reg < REG > where REG :: Ux : Send { } impl < REG : RegisterSpec > Reg < REG > { # [doc = " Returns the underlying memory address of register."]
# [doc = ""]
# [doc = " ```ignore"]
# [doc = " let reg_ptr = periph.reg.as_ptr();"]
# [doc = " ```"]
# [inline (always)]
pub fn as_ptr (& self) -> * mut REG :: Ux { self . register . as_ptr () } } impl < REG : Readable > Reg < REG > { # [doc = " Reads the contents of a `Readable` register."]
# [doc = ""]
# [doc = " You can read the raw contents of a register by using `bits`:"]
# [doc = " ```ignore"]
# [doc = " let bits = periph.reg.read().bits();"]
# [doc = " ```"]
# [doc = " or get the content of a particular field of a register:"]
# [doc = " ```ignore"]
# [doc = " let reader = periph.reg.read();"]
# [doc = " let bits = reader.field1().bits();"]
# [doc = " let flag = reader.field2().bit_is_set();"]
# [doc = " ```"]
# [inline (always)]
pub fn read (& self) -> R < REG > { R { bits : self . register . get () , _reg : marker :: PhantomData , } } } impl < REG : Resettable + Writable > Reg < REG > { # [doc = " Writes the reset value to `Writable` register."]
# [doc = ""]
# [doc = " Resets the register to its initial state."]
# [inline (always)]
pub fn reset (& self) { self . register . set (REG :: RESET_VALUE) } # [doc = " Writes bits to a `Writable` register."]
# [doc = ""]
# [doc = " You can write raw bits into a register:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.write(|w| unsafe { w.bits(rawbits) });"]
# [doc = " ```"]
# [doc = " or write only the fields you need:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.write(|w| w"]
# [doc = "     .field1().bits(newfield1bits)"]
# [doc = "     .field2().set_bit()"]
# [doc = "     .field3().variant(VARIANT)"]
# [doc = " );"]
# [doc = " ```"]
# [doc = " or an alternative way of saying the same:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.write(|w| {"]
# [doc = "     w.field1().bits(newfield1bits);"]
# [doc = "     w.field2().set_bit();"]
# [doc = "     w.field3().variant(VARIANT)"]
# [doc = " });"]
# [doc = " ```"]
# [doc = " In the latter case, other fields will be set to their reset value."]
# [inline (always)]
pub fn write < F > (& self , f : F) where F : FnOnce (& mut W < REG >) -> & mut W < REG > , { self . register . set (f (& mut W { bits : REG :: RESET_VALUE & ! REG :: ONE_TO_MODIFY_FIELDS_BITMAP | REG :: ZERO_TO_MODIFY_FIELDS_BITMAP , _reg : marker :: PhantomData , }) . bits ,) ; } } impl < REG : Writable > Reg < REG > { # [doc = " Writes 0 to a `Writable` register."]
# [doc = ""]
# [doc = " Similar to `write`, but unused bits will contain 0."]
# [doc = ""]
# [doc = " # Safety"]
# [doc = ""]
# [doc = " Unsafe to use with registers which don't allow to write 0."]
# [inline (always)]
pub unsafe fn write_with_zero < F > (& self , f : F) where F : FnOnce (& mut W < REG >) -> & mut W < REG > , { self . register . set (f (& mut W { bits : REG :: Ux :: default () , _reg : marker :: PhantomData , }) . bits ,) ; } } impl < REG : Readable + Writable > Reg < REG > { # [doc = " Modifies the contents of the register by reading and then writing it."]
# [doc = ""]
# [doc = " E.g. to do a read-modify-write sequence to change parts of a register:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.modify(|r, w| unsafe { w.bits("]
# [doc = "    r.bits() | 3"]
# [doc = " ) });"]
# [doc = " ```"]
# [doc = " or"]
# [doc = " ```ignore"]
# [doc = " periph.reg.modify(|_, w| w"]
# [doc = "     .field1().bits(newfield1bits)"]
# [doc = "     .field2().set_bit()"]
# [doc = "     .field3().variant(VARIANT)"]
# [doc = " );"]
# [doc = " ```"]
# [doc = " or an alternative way of saying the same:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.modify(|_, w| {"]
# [doc = "     w.field1().bits(newfield1bits);"]
# [doc = "     w.field2().set_bit();"]
# [doc = "     w.field3().variant(VARIANT)"]
# [doc = " });"]
# [doc = " ```"]
# [doc = " Other fields will have the value they had before the call to `modify`."]
# [inline (always)]
pub fn modify < F > (& self , f : F) where for < 'w > F : FnOnce (& R < REG > , & 'w mut W < REG >) -> & 'w mut W < REG > , { let bits = self . register . get () ; self . register . set (f (& R { bits , _reg : marker :: PhantomData , } , & mut W { bits : bits & ! REG :: ONE_TO_MODIFY_FIELDS_BITMAP | REG :: ZERO_TO_MODIFY_FIELDS_BITMAP , _reg : marker :: PhantomData , } ,) . bits ,) ; } } # [doc (hidden)]
pub mod raw { use super :: { marker , BitM , FieldSpec , RegisterSpec , Unsafe , Writable } ; pub struct R < REG : RegisterSpec > { pub (crate) bits : REG :: Ux , pub (super) _reg : marker :: PhantomData < REG > , } pub struct W < REG : RegisterSpec > { # [doc = "Writable bits"]
pub (crate) bits : REG :: Ux , pub (super) _reg : marker :: PhantomData < REG > , } pub struct FieldReader < FI = u8 > where FI : FieldSpec , { pub (crate) bits : FI :: Ux , _reg : marker :: PhantomData < FI > , } impl < FI : FieldSpec > FieldReader < FI > { # [doc = " Creates a new instance of the reader."]
# [allow (unused)]
# [inline (always)]
pub (crate) const fn new (bits : FI :: Ux) -> Self { Self { bits , _reg : marker :: PhantomData , } } } pub struct BitReader < FI = bool > { pub (crate) bits : bool , _reg : marker :: PhantomData < FI > , } impl < FI > BitReader < FI > { # [doc = " Creates a new instance of the reader."]
# [allow (unused)]
# [inline (always)]
pub (crate) const fn new (bits : bool) -> Self { Self { bits , _reg : marker :: PhantomData , } } } pub struct FieldWriter < 'a , REG , const WI : u8 , FI = u8 , Safety = Unsafe > where REG : Writable + RegisterSpec , FI : FieldSpec , { pub (crate) w : & 'a mut W < REG > , pub (crate) o : u8 , _field : marker :: PhantomData < (FI , Safety) > , } impl < 'a , REG , const WI : u8 , FI , Safety > FieldWriter < 'a , REG , WI , FI , Safety > where REG : Writable + RegisterSpec , FI : FieldSpec , { # [doc = " Creates a new instance of the writer"]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (w : & 'a mut W < REG > , o : u8) -> Self { Self { w , o , _field : marker :: PhantomData , } } } pub struct BitWriter < 'a , REG , FI = bool , M = BitM > where REG : Writable + RegisterSpec , bool : From < FI > , { pub (crate) w : & 'a mut W < REG > , pub (crate) o : u8 , _field : marker :: PhantomData < (FI , M) > , } impl < 'a , REG , FI , M > BitWriter < 'a , REG , FI , M > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = " Creates a new instance of the writer"]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (w : & 'a mut W < REG > , o : u8) -> Self { Self { w , o , _field : marker :: PhantomData , } } } } # [doc = " Register reader."]
# [doc = ""]
# [doc = " Result of the `read` methods of registers. Also used as a closure argument in the `modify`"]
# [doc = " method."]
pub type R < REG > = raw :: R < REG > ; impl < REG : RegisterSpec > R < REG > { # [doc = " Reads raw bits from register."]
# [inline (always)]
pub const fn bits (& self) -> REG :: Ux { self . bits } } impl < REG : RegisterSpec , FI > PartialEq < FI > for R < REG > where REG :: Ux : PartialEq , FI : Copy , REG :: Ux : From < FI > , { # [inline (always)]
fn eq (& self , other : & FI) -> bool { self . bits . eq (& REG :: Ux :: from (* other)) } } # [doc = " Register writer."]
# [doc = ""]
# [doc = " Used as an argument to the closures in the `write` and `modify` methods of the register."]
pub type W < REG > = raw :: W < REG > ; # [doc = " Field reader."]
# [doc = ""]
# [doc = " Result of the `read` methods of fields."]
pub type FieldReader < FI = u8 > = raw :: FieldReader < FI > ; # [doc = " Bit-wise field reader"]
pub type BitReader < FI = bool > = raw :: BitReader < FI > ; impl < FI : FieldSpec > FieldReader < FI > { # [doc = " Reads raw bits from field."]
# [inline (always)]
pub const fn bits (& self) -> FI :: Ux { self . bits } } impl < FI > PartialEq < FI > for FieldReader < FI > where FI : FieldSpec + Copy , { # [inline (always)]
fn eq (& self , other : & FI) -> bool { self . bits . eq (& FI :: Ux :: from (* other)) } } impl < FI > PartialEq < FI > for BitReader < FI > where FI : Copy , bool : From < FI > , { # [inline (always)]
fn eq (& self , other : & FI) -> bool { self . bits . eq (& bool :: from (* other)) } } impl < FI > BitReader < FI > { # [doc = " Value of the field as raw bits."]
# [inline (always)]
pub const fn bit (& self) -> bool { self . bits } # [doc = " Returns `true` if the bit is clear (0)."]
# [inline (always)]
pub const fn bit_is_clear (& self) -> bool { ! self . bit () } # [doc = " Returns `true` if the bit is set (1)."]
# [inline (always)]
pub const fn bit_is_set (& self) -> bool { self . bit () } } # [doc (hidden)]
pub struct Safe ; # [doc (hidden)]
pub struct Unsafe ; # [doc = " Write field Proxy with unsafe `bits`"]
pub type FieldWriter < 'a , REG , const WI : u8 , FI = u8 > = raw :: FieldWriter < 'a , REG , WI , FI , Unsafe > ; # [doc = " Write field Proxy with safe `bits`"]
pub type FieldWriterSafe < 'a , REG , const WI : u8 , FI = u8 > = raw :: FieldWriter < 'a , REG , WI , FI , Safe > ; impl < 'a , REG , const WI : u8 , FI > FieldWriter < 'a , REG , WI , FI > where REG : Writable + RegisterSpec , FI : FieldSpec , REG :: Ux : From < FI :: Ux > , { # [doc = " Field width"]
pub const WIDTH : u8 = WI ; # [doc = " Field width"]
# [inline (always)]
pub const fn width (& self) -> u8 { WI } # [doc = " Field offset"]
# [inline (always)]
pub const fn offset (& self) -> u8 { self . o } # [doc = " Writes raw bits to the field"]
# [doc = ""]
# [doc = " # Safety"]
# [doc = ""]
# [doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (self , value : FI :: Ux) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: mask :: < WI > () << self . o) ; self . w . bits |= (REG :: Ux :: from (value) & REG :: Ux :: mask :: < WI > ()) << self . o ; self . w } # [doc = " Writes `variant` to the field"]
# [inline (always)]
pub fn variant (self , variant : FI) -> & 'a mut W < REG > { unsafe { self . bits (FI :: Ux :: from (variant)) } } } impl < 'a , REG , const WI : u8 , FI > FieldWriterSafe < 'a , REG , WI , FI > where REG : Writable + RegisterSpec , FI : FieldSpec , REG :: Ux : From < FI :: Ux > , { # [doc = " Field width"]
pub const WIDTH : u8 = WI ; # [doc = " Field width"]
# [inline (always)]
pub const fn width (& self) -> u8 { WI } # [doc = " Field offset"]
# [inline (always)]
pub const fn offset (& self) -> u8 { self . o } # [doc = " Writes raw bits to the field"]
# [inline (always)]
pub fn bits (self , value : FI :: Ux) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: mask :: < WI > () << self . o) ; self . w . bits |= (REG :: Ux :: from (value) & REG :: Ux :: mask :: < WI > ()) << self . o ; self . w } # [doc = " Writes `variant` to the field"]
# [inline (always)]
pub fn variant (self , variant : FI) -> & 'a mut W < REG > { self . bits (FI :: Ux :: from (variant)) } } macro_rules ! bit_proxy { ($ writer : ident , $ mwv : ident) => { # [doc (hidden)]
pub struct $ mwv ; # [doc = " Bit-wise write field proxy"]
pub type $ writer <'a , REG , FI = bool > = raw :: BitWriter <'a , REG , FI , $ mwv >; impl <'a , REG , FI > $ writer <'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI >, { # [doc = " Field width"]
pub const WIDTH : u8 = 1 ; # [doc = " Field width"]
# [inline (always)]
pub const fn width (& self) -> u8 { Self :: WIDTH } # [doc = " Field offset"]
# [inline (always)]
pub const fn offset (& self) -> u8 { self . o } # [doc = " Writes bit to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> &'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: one () << self . o) ; self . w . bits |= (REG :: Ux :: from (value) & REG :: Ux :: one ()) << self . o ; self . w } # [doc = " Writes `variant` to the field"]
# [inline (always)]
pub fn variant (self , variant : FI) -> &'a mut W < REG > { self . bit (bool :: from (variant)) } } } ; } bit_proxy ! (BitWriter , BitM) ; bit_proxy ! (BitWriter1S , Bit1S) ; bit_proxy ! (BitWriter0C , Bit0C) ; bit_proxy ! (BitWriter1C , Bit1C) ; bit_proxy ! (BitWriter0S , Bit0S) ; bit_proxy ! (BitWriter1T , Bit1T) ; bit_proxy ! (BitWriter0T , Bit0T) ; impl < 'a , REG , FI > BitWriter < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = " Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W < REG > { self . w . bits |= REG :: Ux :: one () << self . o ; self . w } # [doc = " Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: one () << self . o) ; self . w } } impl < 'a , REG , FI > BitWriter1S < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = " Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W < REG > { self . w . bits |= REG :: Ux :: one () << self . o ; self . w } } impl < 'a , REG , FI > BitWriter0C < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = " Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: one () << self . o) ; self . w } } impl < 'a , REG , FI > BitWriter1C < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = "Clears the field bit by passing one"]
# [inline (always)]
pub fn clear_bit_by_one (self) -> & 'a mut W < REG > { self . w . bits |= REG :: Ux :: one () << self . o ; self . w } } impl < 'a , REG , FI > BitWriter0S < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = "Sets the field bit by passing zero"]
# [inline (always)]
pub fn set_bit_by_zero (self) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: one () << self . o) ; self . w } } impl < 'a , REG , FI > BitWriter1T < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = "Toggle the field bit by passing one"]
# [inline (always)]
pub fn toggle_bit (self) -> & 'a mut W < REG > { self . w . bits |= REG :: Ux :: one () << self . o ; self . w } } impl < 'a , REG , FI > BitWriter0T < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = "Toggle the field bit by passing zero"]
# [inline (always)]
pub fn toggle_bit (self) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: one () << self . o) ; self . w } } } # [cfg (feature = "rt")]
extern "C" { } # [doc (hidden)]
# [repr (C)]
pub union Vector { pub _handler : unsafe extern "C" fn () , pub _reserved : usize , } # [cfg (feature = "rt")]
# [doc (hidden)]
# [no_mangle]
pub static __EXTERNAL_INTERRUPTS : [Vector ; 0]
= []
; # [doc = "SIMPLE"]
pub struct SIMPLE { _marker : PhantomData < * const () > } unsafe impl Send for SIMPLE { } impl SIMPLE { # [doc = r"Pointer to the register block"]
pub const PTR : * const simple :: RegisterBlock = 0x5000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const simple :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for SIMPLE { type Target = simple :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for SIMPLE { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SIMPLE") . finish () } } # [doc = "SIMPLE"]
pub mod simple { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { test : TEST , } impl RegisterBlock { # [doc = "0x00 - "]
# [inline (always)]
pub const fn test (& self) -> & TEST { & self . test } } # [doc = "test (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`test::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`test::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@test`]
module"]
pub type TEST = crate :: Reg < test :: TEST_SPEC > ; # [doc = ""]
pub mod test { # [doc = "Register `test` reader"]
pub type R = crate :: R < TEST_SPEC > ; # [doc = "Register `test` writer"]
pub type W = crate :: W < TEST_SPEC > ; # [doc = "Field `value` reader - simple value register field"]
pub type VALUE_R = crate :: FieldReader ; # [doc = "Field `value` writer - simple value register field"]
pub type VALUE_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `gorf` reader - simple gorf register field"]
pub type GORF_R = crate :: FieldReader ; # [doc = "Field `gorf` writer - simple gorf register field"]
pub type GORF_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R { # [doc = "Bits 0:7 - simple value register field"]
# [inline (always)]
pub fn value (& self) -> VALUE_R { VALUE_R :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 0:7 - simple gorf register field"]
# [inline (always)]
pub fn gorf (& self) -> GORF_R { GORF_R :: new ((self . bits & 0xff) as u8) } } impl W { # [doc = "Bits 0:7 - simple value register field"]
# [inline (always)]
# [must_use]
pub fn value (& mut self) -> VALUE_W < TEST_SPEC > { VALUE_W :: new (self , 0) } # [doc = "Bits 0:7 - simple gorf register field"]
# [inline (always)]
# [must_use]
pub fn gorf (& mut self) -> GORF_W < TEST_SPEC > { GORF_W :: new (self , 0) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`test::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`test::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct TEST_SPEC ; impl crate :: RegisterSpec for TEST_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [`test::R`](R) reader structure"]
impl crate :: Readable for TEST_SPEC { } # [doc = "`write(|w| ..)` method takes [`test::W`](W) writer structure"]
impl crate :: Writable for TEST_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : u16 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u16 = 0 ; } # [doc = "`reset()` method sets test to value 0"]
impl crate :: Resettable for TEST_SPEC { const RESET_VALUE : u16 = 0 ; } } } # [doc = "WIDGET1"]
pub struct WIDGET1 { _marker : PhantomData < * const () > } unsafe impl Send for WIDGET1 { } impl WIDGET1 { # [doc = r"Pointer to the register block"]
pub const PTR : * const widget1 :: RegisterBlock = 0x5004 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const widget1 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for WIDGET1 { type Target = widget1 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for WIDGET1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("WIDGET1") . finish () } } # [doc = "WIDGET1"]
pub mod widget1 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { _reserved_0_test : [u8 ; 0x03]
, } impl RegisterBlock { # [doc = "0x00 - "]
# [inline (always)]
pub const fn config (& self) -> & CONFIG { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (0) . cast () } } # [doc = "0x01 - "]
# [inline (always)]
pub const fn test (& self) -> & TEST { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (1) . cast () } } } # [doc = "config (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`config::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`config::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@config`]
module"]
pub type CONFIG = crate :: Reg < config :: CONFIG_SPEC > ; # [doc = ""]
pub mod config { # [doc = "Register `config` reader"]
pub type R = crate :: R < CONFIG_SPEC > ; # [doc = "Register `config` writer"]
pub type W = crate :: W < CONFIG_SPEC > ; # [doc = "Field `active` reader - widget1 active register field"]
pub type ACTIVE_R = crate :: BitReader ; # [doc = "Field `active` writer - widget1 active register field"]
pub type ACTIVE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `speed` reader - widget1 speed register field"]
pub type SPEED_R = crate :: FieldReader ; # [doc = "Field `speed` writer - widget1 speed register field"]
pub type SPEED_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; # [doc = "Field `stuff` reader - widget1 stuff register field"]
pub type STUFF_R = crate :: FieldReader ; # [doc = "Field `stuff` writer - widget1 stuff register field"]
pub type STUFF_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R { # [doc = "Bit 0 - widget1 active register field"]
# [inline (always)]
pub fn active (& self) -> ACTIVE_R { ACTIVE_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 0:3 - widget1 speed register field"]
# [inline (always)]
pub fn speed (& self) -> SPEED_R { SPEED_R :: new ((self . bits & 0x0f) as u8) } # [doc = "Bits 0:7 - widget1 stuff register field"]
# [inline (always)]
pub fn stuff (& self) -> STUFF_R { STUFF_R :: new ((self . bits & 0xff) as u8) } } impl W { # [doc = "Bit 0 - widget1 active register field"]
# [inline (always)]
# [must_use]
pub fn active (& mut self) -> ACTIVE_W < CONFIG_SPEC > { ACTIVE_W :: new (self , 0) } # [doc = "Bits 0:3 - widget1 speed register field"]
# [inline (always)]
# [must_use]
pub fn speed (& mut self) -> SPEED_W < CONFIG_SPEC > { SPEED_W :: new (self , 0) } # [doc = "Bits 0:7 - widget1 stuff register field"]
# [inline (always)]
# [must_use]
pub fn stuff (& mut self) -> STUFF_W < CONFIG_SPEC > { STUFF_W :: new (self , 0) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`config::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`config::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CONFIG_SPEC ; impl crate :: RegisterSpec for CONFIG_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [`config::R`](R) reader structure"]
impl crate :: Readable for CONFIG_SPEC { } # [doc = "`write(|w| ..)` method takes [`config::W`](W) writer structure"]
impl crate :: Writable for CONFIG_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : u16 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u16 = 0 ; } # [doc = "`reset()` method sets config to value 0"]
impl crate :: Resettable for CONFIG_SPEC { const RESET_VALUE : u16 = 0 ; } } # [doc = "test (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`test::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`test::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@test`]
module"]
pub type TEST = crate :: Reg < test :: TEST_SPEC > ; # [doc = ""]
pub mod test { # [doc = "Register `test` reader"]
pub type R = crate :: R < TEST_SPEC > ; # [doc = "Register `test` writer"]
pub type W = crate :: W < TEST_SPEC > ; # [doc = "Field `bork` reader - widget1 bork register field"]
pub type BORK_R = crate :: FieldReader ; # [doc = "Field `bork` writer - widget1 bork register field"]
pub type BORK_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `awesome` reader - widget1 awesome register field"]
pub type AWESOME_R = crate :: FieldReader ; # [doc = "Field `awesome` writer - widget1 awesome register field"]
pub type AWESOME_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R { # [doc = "Bits 0:7 - widget1 bork register field"]
# [inline (always)]
pub fn bork (& self) -> BORK_R { BORK_R :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 0:7 - widget1 awesome register field"]
# [inline (always)]
pub fn awesome (& self) -> AWESOME_R { AWESOME_R :: new ((self . bits & 0xff) as u8) } } impl W { # [doc = "Bits 0:7 - widget1 bork register field"]
# [inline (always)]
# [must_use]
pub fn bork (& mut self) -> BORK_W < TEST_SPEC > { BORK_W :: new (self , 0) } # [doc = "Bits 0:7 - widget1 awesome register field"]
# [inline (always)]
# [must_use]
pub fn awesome (& mut self) -> AWESOME_W < TEST_SPEC > { AWESOME_W :: new (self , 0) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`test::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`test::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct TEST_SPEC ; impl crate :: RegisterSpec for TEST_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [`test::R`](R) reader structure"]
impl crate :: Readable for TEST_SPEC { } # [doc = "`write(|w| ..)` method takes [`test::W`](W) writer structure"]
impl crate :: Writable for TEST_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : u16 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u16 = 0 ; } # [doc = "`reset()` method sets test to value 0"]
impl crate :: Resettable for TEST_SPEC { const RESET_VALUE : u16 = 0 ; } } } # [doc = "WIDGET2"]
pub struct WIDGET2 { _marker : PhantomData < * const () > } unsafe impl Send for WIDGET2 { } impl WIDGET2 { # [doc = r"Pointer to the register block"]
pub const PTR : * const widget2 :: RegisterBlock = 0x5008 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const widget2 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for WIDGET2 { type Target = widget2 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for WIDGET2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("WIDGET2") . finish () } } # [doc = "WIDGET2"]
pub mod widget2 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { _reserved_0_test : [u8 ; 0x03]
, } impl RegisterBlock { # [doc = "0x00 - "]
# [inline (always)]
pub const fn config (& self) -> & CONFIG { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (0) . cast () } } # [doc = "0x01 - "]
# [inline (always)]
pub const fn test (& self) -> & TEST { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (1) . cast () } } } # [doc = "config (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`config::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`config::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@config`]
module"]
pub type CONFIG = crate :: Reg < config :: CONFIG_SPEC > ; # [doc = ""]
pub mod config { # [doc = "Register `config` reader"]
pub type R = crate :: R < CONFIG_SPEC > ; # [doc = "Register `config` writer"]
pub type W = crate :: W < CONFIG_SPEC > ; # [doc = "Field `active` reader - widget2 active register field"]
pub type ACTIVE_R = crate :: BitReader ; # [doc = "Field `active` writer - widget2 active register field"]
pub type ACTIVE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `speed` reader - widget2 speed register field"]
pub type SPEED_R = crate :: FieldReader ; # [doc = "Field `speed` writer - widget2 speed register field"]
pub type SPEED_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; # [doc = "Field `stuff` reader - widget2 stuff register field"]
pub type STUFF_R = crate :: FieldReader ; # [doc = "Field `stuff` writer - widget2 stuff register field"]
pub type STUFF_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R { # [doc = "Bit 0 - widget2 active register field"]
# [inline (always)]
pub fn active (& self) -> ACTIVE_R { ACTIVE_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 0:3 - widget2 speed register field"]
# [inline (always)]
pub fn speed (& self) -> SPEED_R { SPEED_R :: new ((self . bits & 0x0f) as u8) } # [doc = "Bits 0:7 - widget2 stuff register field"]
# [inline (always)]
pub fn stuff (& self) -> STUFF_R { STUFF_R :: new ((self . bits & 0xff) as u8) } } impl W { # [doc = "Bit 0 - widget2 active register field"]
# [inline (always)]
# [must_use]
pub fn active (& mut self) -> ACTIVE_W < CONFIG_SPEC > { ACTIVE_W :: new (self , 0) } # [doc = "Bits 0:3 - widget2 speed register field"]
# [inline (always)]
# [must_use]
pub fn speed (& mut self) -> SPEED_W < CONFIG_SPEC > { SPEED_W :: new (self , 0) } # [doc = "Bits 0:7 - widget2 stuff register field"]
# [inline (always)]
# [must_use]
pub fn stuff (& mut self) -> STUFF_W < CONFIG_SPEC > { STUFF_W :: new (self , 0) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`config::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`config::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CONFIG_SPEC ; impl crate :: RegisterSpec for CONFIG_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [`config::R`](R) reader structure"]
impl crate :: Readable for CONFIG_SPEC { } # [doc = "`write(|w| ..)` method takes [`config::W`](W) writer structure"]
impl crate :: Writable for CONFIG_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : u16 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u16 = 0 ; } # [doc = "`reset()` method sets config to value 0"]
impl crate :: Resettable for CONFIG_SPEC { const RESET_VALUE : u16 = 0 ; } } # [doc = "test (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`test::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`test::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@test`]
module"]
pub type TEST = crate :: Reg < test :: TEST_SPEC > ; # [doc = ""]
pub mod test { # [doc = "Register `test` reader"]
pub type R = crate :: R < TEST_SPEC > ; # [doc = "Register `test` writer"]
pub type W = crate :: W < TEST_SPEC > ; # [doc = "Field `bork` reader - widget2 bork register field"]
pub type BORK_R = crate :: FieldReader ; # [doc = "Field `bork` writer - widget2 bork register field"]
pub type BORK_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `awesome` reader - widget2 awesome register field"]
pub type AWESOME_R = crate :: FieldReader ; # [doc = "Field `awesome` writer - widget2 awesome register field"]
pub type AWESOME_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R { # [doc = "Bits 0:7 - widget2 bork register field"]
# [inline (always)]
pub fn bork (& self) -> BORK_R { BORK_R :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 0:7 - widget2 awesome register field"]
# [inline (always)]
pub fn awesome (& self) -> AWESOME_R { AWESOME_R :: new ((self . bits & 0xff) as u8) } } impl W { # [doc = "Bits 0:7 - widget2 bork register field"]
# [inline (always)]
# [must_use]
pub fn bork (& mut self) -> BORK_W < TEST_SPEC > { BORK_W :: new (self , 0) } # [doc = "Bits 0:7 - widget2 awesome register field"]
# [inline (always)]
# [must_use]
pub fn awesome (& mut self) -> AWESOME_W < TEST_SPEC > { AWESOME_W :: new (self , 0) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`test::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`test::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct TEST_SPEC ; impl crate :: RegisterSpec for TEST_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [`test::R`](R) reader structure"]
impl crate :: Readable for TEST_SPEC { } # [doc = "`write(|w| ..)` method takes [`test::W`](W) writer structure"]
impl crate :: Writable for TEST_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : u16 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u16 = 0 ; } # [doc = "`reset()` method sets test to value 0"]
impl crate :: Resettable for TEST_SPEC { const RESET_VALUE : u16 = 0 ; } } } # [doc = "COUNTER"]
pub struct COUNTER { _marker : PhantomData < * const () > } unsafe impl Send for COUNTER { } impl COUNTER { # [doc = r"Pointer to the register block"]
pub const PTR : * const counter :: RegisterBlock = 0x500c as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const counter :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for COUNTER { type Target = counter :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for COUNTER { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("COUNTER") . finish () } } # [doc = "COUNTER"]
pub mod counter { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { enable : ENABLE , _reserved_1_counter : [u8 ; 0x04]
, } impl RegisterBlock { # [doc = "0x00 - "]
# [inline (always)]
pub const fn enable (& self) -> & ENABLE { & self . enable } # [doc = "0x01 - "]
# [inline (always)]
pub const fn counter (& self) -> & COUNTER { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (1) . cast () } } # [doc = "0x02 - "]
# [inline (always)]
pub const fn overflow (& self) -> & OVERFLOW { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (2) . cast () } } # [doc = "0x03 - "]
# [inline (always)]
pub const fn prescale (& self) -> & PRESCALE { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (3) . cast () } } } # [doc = "enable (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`enable::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`enable::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@enable`]
module"]
pub type ENABLE = crate :: Reg < enable :: ENABLE_SPEC > ; # [doc = ""]
pub mod enable { # [doc = "Register `enable` reader"]
pub type R = crate :: R < ENABLE_SPEC > ; # [doc = "Register `enable` writer"]
pub type W = crate :: W < ENABLE_SPEC > ; # [doc = "Field `enable` reader - counter enable register field"]
pub type ENABLE_R = crate :: BitReader ; # [doc = "Field `enable` writer - counter enable register field"]
pub type ENABLE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0 - counter enable register field"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (self . bits) } } impl W { # [doc = "Bit 0 - counter enable register field"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < ENABLE_SPEC > { ENABLE_W :: new (self , 0) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`enable::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`enable::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ENABLE_SPEC ; impl crate :: RegisterSpec for ENABLE_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [`enable::R`](R) reader structure"]
impl crate :: Readable for ENABLE_SPEC { } # [doc = "`write(|w| ..)` method takes [`enable::W`](W) writer structure"]
impl crate :: Writable for ENABLE_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : u8 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u8 = 0 ; } # [doc = "`reset()` method sets enable to value 0"]
impl crate :: Resettable for ENABLE_SPEC { const RESET_VALUE : u8 = 0 ; } } # [doc = "counter (r) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`counter::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@counter`]
module"]
pub type COUNTER = crate :: Reg < counter :: COUNTER_SPEC > ; # [doc = ""]
pub mod counter { # [doc = "Register `counter` reader"]
pub type R = crate :: R < COUNTER_SPEC > ; # [doc = "Field `value` reader - counter value register field"]
pub type VALUE_R = crate :: FieldReader < u16 > ; impl R { # [doc = "Bits 0:15 - counter value register field"]
# [inline (always)]
pub fn value (& self) -> VALUE_R { VALUE_R :: new (self . bits) } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`counter::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct COUNTER_SPEC ; impl crate :: RegisterSpec for COUNTER_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [`counter::R`](R) reader structure"]
impl crate :: Readable for COUNTER_SPEC { } # [doc = "`reset()` method sets counter to value 0"]
impl crate :: Resettable for COUNTER_SPEC { const RESET_VALUE : u16 = 0 ; } } # [doc = "overflow (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`overflow::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`overflow::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@overflow`]
module"]
pub type OVERFLOW = crate :: Reg < overflow :: OVERFLOW_SPEC > ; # [doc = ""]
pub mod overflow { # [doc = "Register `overflow` reader"]
pub type R = crate :: R < OVERFLOW_SPEC > ; # [doc = "Register `overflow` writer"]
pub type W = crate :: W < OVERFLOW_SPEC > ; # [doc = "Field `value` reader - counter value register field"]
pub type VALUE_R = crate :: FieldReader < u16 > ; # [doc = "Field `value` writer - counter value register field"]
pub type VALUE_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R { # [doc = "Bits 0:15 - counter value register field"]
# [inline (always)]
pub fn value (& self) -> VALUE_R { VALUE_R :: new (self . bits) } } impl W { # [doc = "Bits 0:15 - counter value register field"]
# [inline (always)]
# [must_use]
pub fn value (& mut self) -> VALUE_W < OVERFLOW_SPEC > { VALUE_W :: new (self , 0) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`overflow::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`overflow::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct OVERFLOW_SPEC ; impl crate :: RegisterSpec for OVERFLOW_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [`overflow::R`](R) reader structure"]
impl crate :: Readable for OVERFLOW_SPEC { } # [doc = "`write(|w| ..)` method takes [`overflow::W`](W) writer structure"]
impl crate :: Writable for OVERFLOW_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : u16 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u16 = 0 ; } # [doc = "`reset()` method sets overflow to value 0"]
impl crate :: Resettable for OVERFLOW_SPEC { const RESET_VALUE : u16 = 0 ; } } # [doc = "prescale (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`prescale::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`prescale::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@prescale`]
module"]
pub type PRESCALE = crate :: Reg < prescale :: PRESCALE_SPEC > ; # [doc = ""]
pub mod prescale { # [doc = "Register `prescale` reader"]
pub type R = crate :: R < PRESCALE_SPEC > ; # [doc = "Register `prescale` writer"]
pub type W = crate :: W < PRESCALE_SPEC > ; # [doc = "Field `value` reader - counter value register field"]
pub type VALUE_R = crate :: FieldReader < u16 > ; # [doc = "Field `value` writer - counter value register field"]
pub type VALUE_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R { # [doc = "Bits 0:15 - counter value register field"]
# [inline (always)]
pub fn value (& self) -> VALUE_R { VALUE_R :: new (self . bits) } } impl W { # [doc = "Bits 0:15 - counter value register field"]
# [inline (always)]
# [must_use]
pub fn value (& mut self) -> VALUE_W < PRESCALE_SPEC > { VALUE_W :: new (self , 0) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`prescale::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`prescale::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct PRESCALE_SPEC ; impl crate :: RegisterSpec for PRESCALE_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [`prescale::R`](R) reader structure"]
impl crate :: Readable for PRESCALE_SPEC { } # [doc = "`write(|w| ..)` method takes [`prescale::W`](W) writer structure"]
impl crate :: Writable for PRESCALE_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : u16 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u16 = 0 ; } # [doc = "`reset()` method sets prescale to value 0"]
impl crate :: Resettable for PRESCALE_SPEC { const RESET_VALUE : u16 = 0 ; } } } # [doc = "COUNTER2"]
pub struct COUNTER2 { _marker : PhantomData < * const () > } unsafe impl Send for COUNTER2 { } impl COUNTER2 { # [doc = r"Pointer to the register block"]
pub const PTR : * const counter2 :: RegisterBlock = 0x5010 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const counter2 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for COUNTER2 { type Target = counter2 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for COUNTER2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("COUNTER2") . finish () } } # [doc = "COUNTER2"]
pub mod counter2 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { enable : ENABLE , _reserved_1_counter : [u8 ; 0x04]
, } impl RegisterBlock { # [doc = "0x00 - "]
# [inline (always)]
pub const fn enable (& self) -> & ENABLE { & self . enable } # [doc = "0x01 - "]
# [inline (always)]
pub const fn counter (& self) -> & COUNTER { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (1) . cast () } } # [doc = "0x02 - "]
# [inline (always)]
pub const fn overflow (& self) -> & OVERFLOW { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (2) . cast () } } # [doc = "0x03 - "]
# [inline (always)]
pub const fn prescale (& self) -> & PRESCALE { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (3) . cast () } } } # [doc = "enable (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`enable::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`enable::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@enable`]
module"]
pub type ENABLE = crate :: Reg < enable :: ENABLE_SPEC > ; # [doc = ""]
pub mod enable { # [doc = "Register `enable` reader"]
pub type R = crate :: R < ENABLE_SPEC > ; # [doc = "Register `enable` writer"]
pub type W = crate :: W < ENABLE_SPEC > ; # [doc = "Field `enable` reader - counter2 enable register field"]
pub type ENABLE_R = crate :: BitReader ; # [doc = "Field `enable` writer - counter2 enable register field"]
pub type ENABLE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0 - counter2 enable register field"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (self . bits) } } impl W { # [doc = "Bit 0 - counter2 enable register field"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < ENABLE_SPEC > { ENABLE_W :: new (self , 0) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`enable::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`enable::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ENABLE_SPEC ; impl crate :: RegisterSpec for ENABLE_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [`enable::R`](R) reader structure"]
impl crate :: Readable for ENABLE_SPEC { } # [doc = "`write(|w| ..)` method takes [`enable::W`](W) writer structure"]
impl crate :: Writable for ENABLE_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : u8 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u8 = 0 ; } # [doc = "`reset()` method sets enable to value 0"]
impl crate :: Resettable for ENABLE_SPEC { const RESET_VALUE : u8 = 0 ; } } # [doc = "counter (r) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`counter::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@counter`]
module"]
pub type COUNTER = crate :: Reg < counter :: COUNTER_SPEC > ; # [doc = ""]
pub mod counter { # [doc = "Register `counter` reader"]
pub type R = crate :: R < COUNTER_SPEC > ; # [doc = "Field `value` reader - counter2 value register field"]
pub type VALUE_R = crate :: FieldReader < u16 > ; impl R { # [doc = "Bits 0:15 - counter2 value register field"]
# [inline (always)]
pub fn value (& self) -> VALUE_R { VALUE_R :: new (self . bits) } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`counter::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct COUNTER_SPEC ; impl crate :: RegisterSpec for COUNTER_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [`counter::R`](R) reader structure"]
impl crate :: Readable for COUNTER_SPEC { } # [doc = "`reset()` method sets counter to value 0"]
impl crate :: Resettable for COUNTER_SPEC { const RESET_VALUE : u16 = 0 ; } } # [doc = "overflow (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`overflow::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`overflow::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@overflow`]
module"]
pub type OVERFLOW = crate :: Reg < overflow :: OVERFLOW_SPEC > ; # [doc = ""]
pub mod overflow { # [doc = "Register `overflow` reader"]
pub type R = crate :: R < OVERFLOW_SPEC > ; # [doc = "Register `overflow` writer"]
pub type W = crate :: W < OVERFLOW_SPEC > ; # [doc = "Field `value` reader - counter2 value register field"]
pub type VALUE_R = crate :: FieldReader < u16 > ; # [doc = "Field `value` writer - counter2 value register field"]
pub type VALUE_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R { # [doc = "Bits 0:15 - counter2 value register field"]
# [inline (always)]
pub fn value (& self) -> VALUE_R { VALUE_R :: new (self . bits) } } impl W { # [doc = "Bits 0:15 - counter2 value register field"]
# [inline (always)]
# [must_use]
pub fn value (& mut self) -> VALUE_W < OVERFLOW_SPEC > { VALUE_W :: new (self , 0) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`overflow::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`overflow::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct OVERFLOW_SPEC ; impl crate :: RegisterSpec for OVERFLOW_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [`overflow::R`](R) reader structure"]
impl crate :: Readable for OVERFLOW_SPEC { } # [doc = "`write(|w| ..)` method takes [`overflow::W`](W) writer structure"]
impl crate :: Writable for OVERFLOW_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : u16 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u16 = 0 ; } # [doc = "`reset()` method sets overflow to value 0"]
impl crate :: Resettable for OVERFLOW_SPEC { const RESET_VALUE : u16 = 0 ; } } # [doc = "prescale (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`prescale::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`prescale::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@prescale`]
module"]
pub type PRESCALE = crate :: Reg < prescale :: PRESCALE_SPEC > ; # [doc = ""]
pub mod prescale { # [doc = "Register `prescale` reader"]
pub type R = crate :: R < PRESCALE_SPEC > ; # [doc = "Register `prescale` writer"]
pub type W = crate :: W < PRESCALE_SPEC > ; # [doc = "Field `value` reader - counter2 value register field"]
pub type VALUE_R = crate :: FieldReader < u16 > ; # [doc = "Field `value` writer - counter2 value register field"]
pub type VALUE_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R { # [doc = "Bits 0:15 - counter2 value register field"]
# [inline (always)]
pub fn value (& self) -> VALUE_R { VALUE_R :: new (self . bits) } } impl W { # [doc = "Bits 0:15 - counter2 value register field"]
# [inline (always)]
# [must_use]
pub fn value (& mut self) -> VALUE_W < PRESCALE_SPEC > { VALUE_W :: new (self , 0) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`prescale::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`prescale::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct PRESCALE_SPEC ; impl crate :: RegisterSpec for PRESCALE_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [`prescale::R`](R) reader structure"]
impl crate :: Readable for PRESCALE_SPEC { } # [doc = "`write(|w| ..)` method takes [`prescale::W`](W) writer structure"]
impl crate :: Writable for PRESCALE_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : u16 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u16 = 0 ; } # [doc = "`reset()` method sets prescale to value 0"]
impl crate :: Resettable for PRESCALE_SPEC { const RESET_VALUE : u16 = 0 ; } } } # [doc = "SERIAL"]
pub struct SERIAL { _marker : PhantomData < * const () > } unsafe impl Send for SERIAL { } impl SERIAL { # [doc = r"Pointer to the register block"]
pub const PTR : * const serial :: RegisterBlock = 0x5100 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const serial :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for SERIAL { type Target = serial :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for SERIAL { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SERIAL") . finish () } } # [doc = "SERIAL"]
pub mod serial { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { _reserved_0_ckd : [u8 ; 0x04]
, txd : TXD , } impl RegisterBlock { # [doc = "0x00 - "]
# [inline (always)]
pub const fn ckd (& self) -> & CKD { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (0) . cast () } } # [doc = "0x01 - "]
# [inline (always)]
pub const fn rxs (& self) -> & RXS { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (1) . cast () } } # [doc = "0x02 - "]
# [inline (always)]
pub const fn rxd (& self) -> & RXD { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (2) . cast () } } # [doc = "0x03 - "]
# [inline (always)]
pub const fn txs (& self) -> & TXS { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (3) . cast () } } # [doc = "0x04 - "]
# [inline (always)]
pub const fn txd (& self) -> & TXD { & self . txd } } # [doc = "CKD (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ckd::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ckd::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ckd`]
module"]
pub type CKD = crate :: Reg < ckd :: CKD_SPEC > ; # [doc = ""]
pub mod ckd { # [doc = "Register `CKD` reader"]
pub type R = crate :: R < CKD_SPEC > ; # [doc = "Register `CKD` writer"]
pub type W = crate :: W < CKD_SPEC > ; # [doc = "Field `divisor` reader - serial divisor register field"]
pub type DIVISOR_R = crate :: FieldReader < u32 > ; # [doc = "Field `divisor` writer - serial divisor register field"]
pub type DIVISOR_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31 - serial divisor register field"]
# [inline (always)]
pub fn divisor (& self) -> DIVISOR_R { DIVISOR_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - serial divisor register field"]
# [inline (always)]
# [must_use]
pub fn divisor (& mut self) -> DIVISOR_W < CKD_SPEC > { DIVISOR_W :: new (self , 0) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ckd::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ckd::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CKD_SPEC ; impl crate :: RegisterSpec for CKD_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`ckd::R`](R) reader structure"]
impl crate :: Readable for CKD_SPEC { } # [doc = "`write(|w| ..)` method takes [`ckd::W`](W) writer structure"]
impl crate :: Writable for CKD_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CKD to value 0"]
impl crate :: Resettable for CKD_SPEC { const RESET_VALUE : u32 = 0 ; } } # [doc = "RXS (r) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rxs::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rxs`]
module"]
pub type RXS = crate :: Reg < rxs :: RXS_SPEC > ; # [doc = ""]
pub mod rxs { # [doc = "Register `RXS` reader"]
pub type R = crate :: R < RXS_SPEC > ; # [doc = "Field `rdy` reader - serial rdy register field"]
pub type RDY_R = crate :: BitReader ; impl R { # [doc = "Bit 0 - serial rdy register field"]
# [inline (always)]
pub fn rdy (& self) -> RDY_R { RDY_R :: new (self . bits) } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rxs::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RXS_SPEC ; impl crate :: RegisterSpec for RXS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [`rxs::R`](R) reader structure"]
impl crate :: Readable for RXS_SPEC { } # [doc = "`reset()` method sets RXS to value 0"]
impl crate :: Resettable for RXS_SPEC { const RESET_VALUE : u8 = 0 ; } } # [doc = "RXD (r) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rxd::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rxd`]
module"]
pub type RXD = crate :: Reg < rxd :: RXD_SPEC > ; # [doc = ""]
pub mod rxd { # [doc = "Register `RXD` reader"]
pub type R = crate :: R < RXD_SPEC > ; # [doc = "Field `data` reader - serial data register field"]
pub type DATA_R = crate :: FieldReader ; # [doc = "Field `err_overflow` reader - serial err_overflow register field"]
pub type ERR_OVERFLOW_R = crate :: BitReader ; # [doc = "Field `err_frame` reader - serial err_frame register field"]
pub type ERR_FRAME_R = crate :: BitReader ; impl R { # [doc = "Bits 0:7 - serial data register field"]
# [inline (always)]
pub fn data (& self) -> DATA_R { DATA_R :: new ((self . bits & 0xff) as u8) } # [doc = "Bit 0 - serial err_overflow register field"]
# [inline (always)]
pub fn err_overflow (& self) -> ERR_OVERFLOW_R { ERR_OVERFLOW_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 0 - serial err_frame register field"]
# [inline (always)]
pub fn err_frame (& self) -> ERR_FRAME_R { ERR_FRAME_R :: new ((self . bits & 1) != 0) } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rxd::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RXD_SPEC ; impl crate :: RegisterSpec for RXD_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [`rxd::R`](R) reader structure"]
impl crate :: Readable for RXD_SPEC { } # [doc = "`reset()` method sets RXD to value 0"]
impl crate :: Resettable for RXD_SPEC { const RESET_VALUE : u16 = 0 ; } } # [doc = "TXS (r) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`txs::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@txs`]
module"]
pub type TXS = crate :: Reg < txs :: TXS_SPEC > ; # [doc = ""]
pub mod txs { # [doc = "Register `TXS` reader"]
pub type R = crate :: R < TXS_SPEC > ; # [doc = "Field `rdy` reader - serial rdy register field"]
pub type RDY_R = crate :: BitReader ; impl R { # [doc = "Bit 0 - serial rdy register field"]
# [inline (always)]
pub fn rdy (& self) -> RDY_R { RDY_R :: new (self . bits) } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`txs::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct TXS_SPEC ; impl crate :: RegisterSpec for TXS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [`txs::R`](R) reader structure"]
impl crate :: Readable for TXS_SPEC { } # [doc = "`reset()` method sets TXS to value 0"]
impl crate :: Resettable for TXS_SPEC { const RESET_VALUE : u8 = 0 ; } } # [doc = "TXD (w) register accessor: \n\nYou can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`txd::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@txd`]
module"]
pub type TXD = crate :: Reg < txd :: TXD_SPEC > ; # [doc = ""]
pub mod txd { # [doc = "Register `TXD` writer"]
pub type W = crate :: W < TXD_SPEC > ; # [doc = "Field `data` writer - serial data register field"]
pub type DATA_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl W { # [doc = "Bits 0:7 - serial data register field"]
# [inline (always)]
# [must_use]
pub fn data (& mut self) -> DATA_W < TXD_SPEC > { DATA_W :: new (self , 0) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`txd::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct TXD_SPEC ; impl crate :: RegisterSpec for TXD_SPEC { type Ux = u8 ; } # [doc = "`write(|w| ..)` method takes [`txd::W`](W) writer structure"]
impl crate :: Writable for TXD_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : u8 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u8 = 0 ; } # [doc = "`reset()` method sets TXD to value 0"]
impl crate :: Resettable for TXD_SPEC { const RESET_VALUE : u8 = 0 ; } } } # [no_mangle]
static mut DEVICE_PERIPHERALS : bool = false ; # [doc = r" All the peripherals."]
# [allow (non_snake_case)]
pub struct Peripherals { # [doc = "SIMPLE"]
pub SIMPLE : SIMPLE , # [doc = "WIDGET1"]
pub WIDGET1 : WIDGET1 , # [doc = "WIDGET2"]
pub WIDGET2 : WIDGET2 , # [doc = "COUNTER"]
pub COUNTER : COUNTER , # [doc = "COUNTER2"]
pub COUNTER2 : COUNTER2 , # [doc = "SERIAL"]
pub SERIAL : SERIAL , } impl Peripherals { # [doc = r" Returns all the peripherals *once*."]
# [cfg (feature = "critical-section")]
# [inline]
pub fn take () -> Option < Self > { critical_section :: with (| _ | { if unsafe { DEVICE_PERIPHERALS } { return None } Some (unsafe { Peripherals :: steal () }) }) } # [doc = r" Unchecked version of `Peripherals::take`."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Each of the returned peripherals must be used at most once."]
# [inline]
pub unsafe fn steal () -> Self { DEVICE_PERIPHERALS = true ; Peripherals { SIMPLE : SIMPLE { _marker : PhantomData } , WIDGET1 : WIDGET1 { _marker : PhantomData } , WIDGET2 : WIDGET2 { _marker : PhantomData } , COUNTER : COUNTER { _marker : PhantomData } , COUNTER2 : COUNTER2 { _marker : PhantomData } , SERIAL : SERIAL { _marker : PhantomData } , } } }